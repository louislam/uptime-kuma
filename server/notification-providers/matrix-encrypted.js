const NotificationProvider = require("./notification-provider");
const { log } = require("../../src/util");

const sdk = require("matrix-js-sdk");

const fs = require("fs");
const path = require("path");
const { CryptoEvent } = require("matrix-js-sdk/lib/crypto-api");

class MatrixEncrypted extends NotificationProvider {
    name = "matrix-encrypted";

    // Singleton client and store
    static client = null;
    static store = null;

    async send(notification, msg) {
        const okMsg = "Sent Successfully.";

        // Initialize JSON store once
        if (!MatrixEncrypted.store) {
            MatrixEncrypted.store = new JsonCryptoStore("./my_crypto_store2.json");
        }

        // Initialize client once
        if (!MatrixEncrypted.client) {
            MatrixEncrypted.client = sdk.createClient({
                baseUrl: notification.homeserverUrl,
                accessToken: notification.accessToken,
                userId: notification.userId,
                deviceId: notification.deviceId,
                //cryptoStore: MatrixEncrypted.store,
            });

            // Initialize Rust crypto
            await MatrixEncrypted.client.initRustCrypto({ useIndexedDB: false });

            // Listen for verification requests
            this.listenForVerificationRequests(MatrixEncrypted.client);

            // Start client
            await MatrixEncrypted.client.startClient({ initialSyncLimit: 1 });

            // Wait for initial sync
            await new Promise((resolve) => {
                MatrixEncrypted.client.once("sync", (state) => {
                    if (state === "PREPARED") resolve();
                });
            })

            log.info("Matrix", "Client initialized and ready");
        } else {
            log.info("Matrix", "Reusing existing client instance");
        }

        log.info("Matrix", "Sending encrypted messageâ€¦");

        await MatrixEncrypted.client.sendMessage(notification.internalRoomId, {
            msgtype: "m.text",
            body: msg,
        });

        return okMsg;
    }

    listenForVerificationRequests(client) {
        // Coded with assistance by Devin and DeepWiki
        
        // 1. Listen for incoming verification requests  
        client.on(CryptoEvent.VerificationRequestReceived, async (request) => {  
            // 2. Accept the verification request  
            await request.accept();  
            
            // 3. Wait for other party to choose SAS method and start verification  
            request.once("change", async () => {
                // phase 4 is "started"
                if (request.phase === 4 && request.chosenMethod === "m.sas.v1") {  
                    const verifier = request.verifier;  
                    
                    // 4. Start verification  
                    const verificationPromise = verifier.verify();  
                    
                    // 5. Confirm SAS  
                    verifier.once("show_sas", async (showSasCallbacks) => {  
                        // delay mostly added for tests
                        setTimeout(() => {
                            showSasCallbacks.confirm();  
                        }, 5000);
                    });  
                    
                    // 6. Wait for verification to complete  
                    await verificationPromise;  
                }  
            });  
        });
    }
}

/**
 * A simple JSON-file-based CryptoStore for Node.js
 * Compatible with matrix-js-sdk E2EE
 * 
 * Generated by ChatGPT
 */
class JsonCryptoStore {
    /**
     * @param {string} filePath
     */
    constructor(filePath) {
        this.filePath = filePath || path.join(__dirname, "crypto_store.json");
        this.store = {};
        this.loadFromFile();
    }

    loadFromFile() {
        if (fs.existsSync(this.filePath)) {
            try {
                const data = fs.readFileSync(this.filePath, "utf-8");
                this.store = JSON.parse(data);
            } catch (err) {
                console.warn("Failed to load crypto store, starting fresh.", err);
                this.store = {};
            }
        }
    }

    containsData() {
        return false;
    }

    saveToFile() {
        try {
            fs.writeFileSync(this.filePath, JSON.stringify(this.store, null, 2), "utf-8");
        } catch (err) {
            console.error("Failed to save crypto store", err);
        }
    }

    // ICryptoStore interface methods

    async get(name) {
        return this.store[name];
    }

    async set(name, value) {
        this.store[name] = value;
        this.saveToFile();
    }

    async remove(name) {
        delete this.store[name];
        this.saveToFile();
    }

    async getAll() {
        return { ...this.store };
    }

    async doTxn(type, mode, txnFn) {
        // JSON store is in-memory, so txn is a no-op
        return txnFn(null);
    }

    async isNew() {
        return !fs.existsSync(this.filePath);
    }

    async close() {
        // nothing to close
    }
}

module.exports = MatrixEncrypted;