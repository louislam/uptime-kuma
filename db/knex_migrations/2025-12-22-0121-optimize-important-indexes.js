exports.up = function (knex) {
    // Check if we're using SQLite or MariaDB/MySQL
    const isSQLite = knex.client.dialect === "sqlite3";

    if (isSQLite) {
        // For SQLite: Drop existing indexes and create partial indexes with WHERE important = 1
        // This is more efficient since we only query for important = 1
        // The partial index on important alone helps with COUNT queries even though values are identical
        // Note: Drop all possible index name variations (auto-generated by Knex or manually created)
        return knex.raw("DROP INDEX IF EXISTS monitor_important_time_index")
            .then(() => knex.raw("DROP INDEX IF EXISTS important"))
            .then(() => knex.raw("DROP INDEX IF EXISTS heartbeat_important_index"))
            .then(() => knex.raw("CREATE INDEX monitor_important_time_index ON heartbeat (monitor_id, time DESC) WHERE important = 1"))
            .then(() => knex.raw("CREATE INDEX important ON heartbeat (important) WHERE important = 1"));
    } else {
        // For MariaDB/MySQL: Partial indexes are not supported, but we can still optimize
        // Remove the important column from the compound index as it provides minimal benefit
        // when queries already filter explicitly by important = 1
        return knex.schema.alterTable("heartbeat", function (table) {
            table.dropIndex([ "monitor_id", "important", "time" ], "monitor_important_time_index");
        }).then(() => {
            return knex.schema.alterTable("heartbeat", function (table) {
                table.index([ "monitor_id", "time" ], "monitor_important_time_index");
            });
        });
    }
};

exports.down = function (knex) {
    const isSQLite = knex.client.dialect === "sqlite3";

    if (isSQLite) {
        // Restore original indexes without WHERE clause
        return knex.raw("DROP INDEX IF EXISTS monitor_important_time_index")
            .then(() => knex.raw("DROP INDEX IF EXISTS important"))
            .then(() => knex.raw("CREATE INDEX monitor_important_time_index ON heartbeat (monitor_id, important, time)"))
            .then(() => knex.raw("CREATE INDEX important ON heartbeat (important)"));
    } else {
        // Restore original compound index with important column
        return knex.schema.alterTable("heartbeat", function (table) {
            table.dropIndex([ "monitor_id", "time" ], "monitor_important_time_index");
        }).then(() => {
            return knex.schema.alterTable("heartbeat", function (table) {
                table.index([ "monitor_id", "important", "time" ], "monitor_important_time_index");
            });
        });
    }
};
